#!/bin/bash
#
# mksynth - Media Knowledge Synthesizer CLI Wrapper
# User-friendly wrapper for media-knowledge-pipeline
# Automatically handles virtual environment and command translation
#

set -euo pipefail

# Script directory detection
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$SCRIPT_DIR"

# Default configuration
DEFAULT_VENV="media_knowledge_env"
DEFAULT_PROMPT="basic_summary"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() {
    echo -e "${BLUE}INFO${NC}: $1"
}

print_success() {
    echo -e "${GREEN}SUCCESS${NC}: $1"
}

print_warning() {
    echo -e "${YELLOW}WARNING${NC}: $1"
}

print_error() {
    echo -e "${RED}ERROR${NC}: $1"
}

# Function to show usage
show_usage() {
    cat << EOF
Usage: mksynth [OPTIONS] <input>
       mksynth-<template> [OPTIONS] <input>
       mksynth batch [OPTIONS]
       mksynth scan [OPTIONS]

Media Knowledge Synthesizer - Simplified CLI

INPUT FORMATS:
  <input> can be:
  - Single YouTube URL
  - Space-delimited URLs: "url1 url2 url3"
  - Comma-delimited URLs: "url1,url2,url3"
  - YouTube playlist URL
  - Path to file with URLs (one per line)

TEMPLATE-SPECIFIC COMMANDS:
  mksynth-summary    - Use 'basic_summary' template
  mksynth-meeting    - Use 'meeting_minutes' template
  mksynth-lecture    - Use 'lecture_summary' template
  mksynth-tutorial   - Use 'tutorial_guide' template
  mksynth-project    - Use 'project_update' template
  mksynth-customer   - Use 'customer_feedback' template

EXAMPLES:
  # Process single video
  mksynth "https://youtube.com/watch?v=..."
  
  # Process multiple videos
  mksynth "https://youtube.com/video1 https://youtube.com/video2"
  
  # Process with meeting template
  mksynth-meeting "https://youtube.com/watch?v=..."
  
  # Process playlist
  mksynth "https://youtube.com/playlist?list=..."
  
  # Batch process from file
  mksynth batch --urls urls.txt

OPTIONS:
  --cloud            Use Ollama Cloud for synthesis
  --output FILE      Output file path for results
  --markdown DIR     Markdown output directory
  --quiet            Suppress detailed output
  --help             Show this help message

ENVIRONMENT VARIABLES:
  MKSYNTH_VERBOSE    Enable verbose output
  MKSYNTH_CACHE_DIR  Custom cache directory

Report issues: https://github.com/anomalyco/opencode/issues
EOF
}

# Function to check if virtual environment is active
is_venv_active() {
    if [[ -n "${VIRTUAL_ENV:-}" ]]; then
        return 0
    fi
    return 1
}

# Function to activate virtual environment
activate_venv() {
    local venv_path="$1"
    
    if [[ ! -d "$venv_path" ]]; then
        print_error "Virtual environment not found: $venv_path"
        print_info "Create a virtual environment with: python -m venv $venv_path"
        return 1
    fi
    
    source "$venv_path/bin/activate"
    print_info "Activated virtual environment: $venv_path"
}

# Function to detect shell command (if running via alias)
detect_template_command() {
    local command_name="$(basename "$0")"
    
    # Check if command starts with mksynth-
    if [[ "$command_name" == mksynth-* ]]; then
        local template="${command_name#mksynth-}"
        echo "$template"
    fi
}

# Function to check if input is a URL
is_url() {
    local input="$1"
    [[ "$input" =~ ^https?:// ]] || [[ "$input" =~ ^youtu\.?be ]]
}

# Function to check if input is a file
is_file() {
    local input="$1"
    [[ -f "$input" ]]
}

# Function to check if input contains multiple URLs
is_url_list() {
    local input="$1"
    
    # Check for comma-separated URLs
    if [[ "$input" == *,* ]]; then
        return 0
    fi
    
    # Check for space-separated URLs
    local url_count=$(echo "$input" | tr ' ' '\n' | grep -c '^https\?://')
    [[ $url_count -gt 1 ]]
}

# Function to parse URL list
parse_url_list() {
    local input="$1"
    
    # Handle comma-separated URLs
    if [[ "$input" == *,* ]]; then
        echo "$input" | tr ',' '\n' | grep '^https\?://' | tr '\n' ' '
    else
        echo "$input"
    fi
}

# Function to create temporary URLs file
create_urls_file() {
    local urls="$1"
    local temp_file="$(mktemp)"
    
    # Parse URLs and write to file
    parse_url_list "$urls" | tr ' ' '\n' > "$temp_file"
    echo "$temp_file"
}

# Function to detect command type and translate
detect_and_translate_command() {
    local args=("$@")
    local translated_args=()
    local template=""
    local command="process"
    
    # Check for template-specific command
    local detected_template=$(detect_template_command)
    if [[ -n "$detected_template" ]]; then
        template="$detected_template"
        translated_args+=("--prompt" "$template")
    fi
    
    # Check for subcommands
    if [[ "${args[0]:-}" == "batch" ]]; then
        command="batch"
        args=("${args[@]:1}")
    elif [[ "${args[0]:-}" == "scan" ]]; then
        command="scan"
        args=("${args[@]:1}")
    elif [[ "${args[0]:-}" == "watch" ]]; then
        command="watch"
        args=("${args[@]:1}")
    fi
    
    # Parse options and input
    local input=""
    local i=0
    while [[ $i -lt ${#args[@]} ]]; do
        case "${args[$i]}" in
            --help|-h)
                show_usage
                exit 0
                ;;
            --cloud)
                translated_args+=("--cloud")
                ;;
            --output|-o)
                translated_args+=("--output" "${args[$((i+1))]}")
                ((i++))
                ;;
            --markdown|-m)
                translated_args+=("--markdown" "${args[$((i+1))]}")
                ((i++))
                ;;
            --quiet|-q)
                translated_args+=("--quiet")
                ;;
            --parallel|-j)
                translated_args+=("--parallel" "${args[$((i+1))]}")
                ((i++))
                ;;
            --urls|-u)
                translated_args+=("--urls" "${args[$((i+1))]}")
                ((i++))
                ;;
            --directory|-d)
                translated_args+=("--directory" "${args[$((i+1))]}")
                ((i++))
                ;;
            --process)
                translated_args+=("--process")
                ;;
            --dry-run)
                translated_args+=("--dry-run")
                ;;
            -*)
                print_error "Unknown option: ${args[$i]}"
                show_usage
                exit 1
                ;;
            *)
                # This is the input
                if [[ -z "$input" ]]; then
                    input="${args[$i]}"
                else
                    print_error "Multiple input arguments provided"
                    show_usage
                    exit 1
                fi
                ;;
        esac
        ((i++))
    done
    
    # Handle input based on command type
    if [[ "$command" == "process" ]]; then
        if [[ -z "$input" ]]; then
            print_error "No input provided"
            show_usage
            exit 1
        fi
        
        # Check input type and translate
        if is_url_list "$input"; then
            # Multiple URLs - create temporary file and use batch command
            print_info "Detected multiple URLs, using batch processing"
            command="batch"
            local temp_file="$(create_urls_file "$input")"
            translated_args+=("--urls" "$temp_file")
            # Clean up temp file after processing
            trap "rm -f '$temp_file'" EXIT
        elif is_file "$input"; then
            # File containing URLs
            command="batch"
            translated_args+=("--urls" "$input")
        else
            # Single URL
            translated_args+=("--input" "$input")
        fi
    elif [[ "$command" == "batch" ]]; then
        # Ensure --urls is provided for batch command
        if ! printf '%s\n' "${translated_args[@]}" | grep -q "^--urls$"; then
            print_error "Batch command requires --urls argument"
            show_usage
            exit 1
        fi
    fi
    
    printf "%s\n" "$command"
    for arg in "${translated_args[@]}"; do
        printf "%s\n" "$arg"
    done
}

# Main execution function
main() {
    local args=("$@")
    
    # Show help if no arguments
    if [[ ${#args[@]} -eq 0 ]]; then
        show_usage
        exit 0
    fi
    
    # Check for virtual environment
    if ! is_venv_active; then
        print_info "Activating virtual environment"
        if ! activate_venv "$PROJECT_ROOT/$DEFAULT_VENV"; then
            print_error "Failed to activate virtual environment"
            exit 1
        fi
    else
        print_info "Using active virtual environment: $VIRTUAL_ENV"
    fi
    
    # Detect and translate command
    local translated_parts
    translated_parts=$(detect_and_translate_command "${args[@]}")
    
    if [[ $? -ne 0 ]]; then
        print_error "Failed to translate command"
        exit 1
    fi
    
    # Parse the translated parts into an array (macOS compatible)
    IFS=$'\n' read -r -d '' -a translated_array <<< "$translated_parts"
    
    # Get command and arguments
    local command="${translated_array[0]}"
    local command_args=("${translated_array[@]:1}")
    
    # Execute the translated command
    print_info "Executing: python main.py $command ${command_args[*]}"
    
    cd "$PROJECT_ROOT"
    python main.py "$command" "${command_args[@]}"
    
    local exit_code=$?
    
    if [[ $exit_code -eq 0 ]]; then
        print_success "Processing completed successfully"
    else
        print_error "Processing failed with exit code $exit_code"
    fi
    
    exit $exit_code
}

# Run main function with all arguments
main "$@"